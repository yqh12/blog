# 八股文整理
## 1. seesion怎么实现登录的功能：
首先session是一种在服务端存储用户信息的这样一个功能，在jsp中运用的时候是作为一种域来存储用户信息，用户的在登陆的时候，因为session具有追踪效果，会吧用户的信息存储在服务器上，并且给予这个用户一个sessionid存储在客户端的cookie或者locstorage，然后在用户访问的时候cookie携带这样的session到服务器，根据session的存储信息获取这个用户的信息，然后实现登录功能
## 2. css的优先级与层叠性：
首先ccs的优先级是 ！importan>内联样式>id选择器>class选择器>标签选择器>通配选择器 其中，像important的权重为10000，内联为1000，id为0100，class为0010，标签和伪类是0001，通配为0，层叠性则是在相同的选择器下，后面出现的选择器的样式覆盖前面的样式
## 3. this的用法:
在普通的函数中运行的时候，this指向的是window，因为在一个普通函数创立的时候，或者对于浏览器自带的函数，都是挂载在window上面的，我们也可以通过浏览器的控制台可以看到很多变量和函数都在window上。而在应该对象的方法中调用这个函数，那么这个this是指向这个对象内部，像在object中创建一个函数，那其this指向这个this.a===object.a。这个函数作为构造函数来用的话，在执行的时候这个this指向的是创建的这个对象，来对其进行赋值。还有就是在箭头函数中的this是用其创建的上下文中的this来指代。最后就是在使用apply，call和bind这三个方法可以用来改变this的指向
## 4. 基本数据类型：
number，string，symbol，boolen，bigint，null，undefined。引用数据类型：object，array,function

## 5. 判断数据类型的方法有哪些
typeof,instanceof,object.proptype.tostring.call()。其中typeof判断数据类型的时候只能准确判断基本数据类型，像null与array都是会被判断成为object。instancof是只能准确判断引用数据类型，像number，string，boolen无法准确判断，因为instanceof通过原型链来进行判断类型，而基本数据类型没有原型，object.proptype.tostring.call()可以进行准确判断
## 6. Computed的特点：
首先Computed是计算属性，他是在其所依赖的属性在改变的时候进行计算，会自动侦听其在data中所需要计算的元素并进行缓存，用于计算比较消耗计算量的场景，在代码中显示就是，在一个data中这个元素如果进行了改变，那么其所对应的computed的方法会进行计算，从而改变视图，一般用于一个许多属性会造成其变化的属性
## 7. flex的用法和方法：
使用flex，会把盒子变成弹性盒子，flex的属性有这几个，flex-direction，用于决定主轴的方向；flex-wrap用于决定换行的方向；flex-flow：是前俩个属性的复合属性；justify-content：主轴的对齐方式；align-items:垂直轴线的对齐方式。然后布局在弹性容器上面的属性，是通过flex-grow，flex-shrink，flex-basis这三个属性控制
## 8. vue的数据绑定：
vue.js是采用数据劫持结合发布者-订阅者模式的方式,通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时发布消息给订阅者，触发相应的监听回调
## 9. ssr：
服务器渲染，通过服务器对http文档进行渲染，渲染完成后传给客户端进行页面展示，其优点是因为是通过服务器渲染的，首屏加载快，seo优化好，并且利于处理大型的http文档，但是需要服务器进行渲染，可能成本比较大；csr:通过客户端渲染，直接在页面上进行展示。相比于ssr，首屏加载慢，seo不友好，可维护性较强，响应速度快，并且交互动画等渲染快。
## 10.长列表：
其实就是可以通过长列表优化来实现，主要就是根据你的可视区域来实现数据或者文本的展现，就像滑动窗口一样，可以通过你窗口的改变来加载你所需要的上下文节点的数据。其优化主要是看你这个数据根据你这个窗口需要加载的多少并且不会让用户看出来你是长列表。
## 11.promise：
说promise，就要说到异步，因为异步的解决方案有像promise，回调函数，asnyc/await，而promise的使用可以避免回调地狱，promise有三种状态，进行中，成功与失败。成功与失败只能变化一次，改变状态之后无法再改变。如果promise成功那链式then就会输出，如果失败则会输出catch。而其实改变其都是异步任务中的微任务。promise有promise.all,promise.race,promise.then,promise.catch,promise.finally这几种方法。如果链式太多可以使用all或者使用asnyc/await。
## 12. 怎么用flex实现水平居中并且水平靠左:
使用alients-itme：center来实现垂直居中，然后再使用ustify-content：flex-start来实现水平靠左
## 13.importan和require的区别
俩个都是模块的引入方法。
improt 引入只能在js文件的最上方进行引入，而require则是可以在文件的任何地方进行引入。而import是基于es6实现的，而require是基于CommonJS实现的。在使用require的时候js文件会停下来加载模块，而import是通过异步加载的在代码执行之前进行加载。
## 14.  axios是什么****
axios是一个基于promise封装的http客户端，可以进行前后端交互的这样一个库，他支持promise库，可以拦截与响应请求，还能转化数据或者json数据。
## 15. 盒模型
盒模型主要分为俩种，一种是标准盒模型，一直是ie盒模型，他们的区别主要是其长宽是否包含了padding和margin，如果是标准盒模型，其长宽只包含了content，其转换可以通过box-sizing进行转换
## 16. less与sass的区别
俩种都是css的预处理，可以通过像考拉这样的软件进行编译，其主要是为了减少代码的冗余与提高可维护性，像使用css时需要多重复写很多样式，通过这样的预处理器可以快速修改和维护css代码，而像less和sass可以使用变量或者函数，还可以嵌套书写。$与@来写变量。
## 17. ==的工作原理与如何强制转换
==是通过对数据的强制转换来比较俩者是否相同，对应的是===，===是比较俩者是否完全相同来判断正确与否。==的强制类型转换如果两个操作数的类型相同,则直接比较它们的值。如果操作数中有布尔值,则先将布尔值转换为数字,再进行比较。如果其中一个操作数是字符串,另一个是数字,则将字符串转换为数字,再进行比较。如果其中一个操作数是对象,另一个不是,则调用对象的 `valueOf()` 方法获取原始值,再进行比较。如果无法获取原始值,则调用 `toString()` 方法获取字符串,再进行比较。有Number，String，Boolen这种强制转换方法
## 18. 深拷贝
是因为引用数据类型是有堆栈的，像基本数据类型只有栈，里面直接存储了值，而引用数据类型在栈上存储的是堆的内存地址，在进行拷贝的时候，复制的单纯是其地址而不是展现的数据，所以会有深拷贝，就是实现拷贝出来一个新的堆并且复制其数据，让新的栈指向这个堆
## 19. 深拷贝实现：


```js
function deepClone(obj){
if(!obj instanceof object ||!obj instanceof Array){
    return obj
}
let target=obj instanceof Array? []:{}
    for(let key in obj){
         if(obj.hasOwnProperty(key)){
             if(!obj[key] instanceof object ||!obj[key] instanceof Array){
                    target[key]=obj[key]                    
                                    }
             else{
                 target[key]=deepClone(obj[key])
                 }
                 }
     }
     return target

}

```
## 20. 事件循环
js是一种单线程的语言，所以在运行的时候会一步步按照代码顺序进行运行，可是在运行的时候会出现加载时间过长，页面堵塞的情况，所以出现了异步这样的情况。而事件循环中，首先是对于整个同步任务的进行，加载到异步时会放入浏览器所支持的webapi中，并且在加载完成后放入任务队列，在同步任务执行完之后会把任务队列中的任务通过event loop压入调用栈中，而在这上面任务又分为微任务与宏任务，像promise.then,all等都是微任务，而settimeout是宏任务，会先执行微任务，再进行下一个宏任务循环。

## 21. settimeout的执行时间是肯定的吗
是不一定的，因为在执行过程中还要有对同步任务执行，或者对一些数据的加载，所以执行时间不是像自己所标注一样准确，而是会需要更多的的时间

## 22. 垃圾回收机制
就是在浏览器渲染完成之后，浏览器中没有用处的变量会被清除，减少浏览器的内存消耗。主要有三种方式来清除，一种是通过标记清除法，就是在变量进入时给一个标记，在不使用的时候清除标记，最后把没有标记的变量清除。一直是引用清除，就是在引用的时候加一，重置的时候减一，最后清除为0的变量。最后一种是v8清除法，主要用在谷歌浏览器，是将变量分为老生代和新生代，使用次数多的放在老生代而使用次数少的放在新生代，而在新生代中回收次数多，老生代回收次数少。
## 23. 原型链
首先每一个构造函数创建的时候都会有一个对象属性，prototype，而构造函数创建一个对象，会有一个proto指向这个prototype，也由此可以使用这个函数的方法和属性，而每一个实例对象都会有一个construct指向其对应的构造函数，由此因为prototype也是一个对象，其也会有一个proto来指向其构造函数的prototype，所以在查找一个对象的方法与属性的时候，会先从他的proto来查找，再网上查找。如差找一个array的对象，那先会去查找Array构造函数的方法与属性，如果没有找到就再去找function构造函数的方法与属性，原型最终是object，因为object.proto是null
## 24. 伪类的用法
 `:hover` 鼠标悬停时的展示 `:focus` 标签获得焦点的时候 `:active` 鼠标点击时候的状态  `:link` 未访问时候的状态 `:visited` 已经访问过的状态  `:first-child` 多用于选中组件内表的样式进行修改 `:enable` 控件可使用的状态 `:disable` 控件不可使用的状态
 与伪元素的不同是在伪类只是对于选择器的扩展，而伪元素则是创造了新的元素并且可以添加样式，但是伪类在dom中真实存在，伪元素在dom中不存在但是可以装载样式
 伪元素有`::before` 所选元素的第一个子元素和 `::after` 所选元素的最后一个元素 `::first-letter` 第一个字的样式 -   `::selection` 修改鼠标选中项的样式`::placeholder` 修改输入框占位符的样式
## 25. git命令
git add 
git branch
git commit
git merch
git fetch
git push
git  pop
git checkout
## 26. html如何把他变成html树
栈加上递归可以实现，像（）{}[]的判断一样把树的标签给分开，再通过二叉树的递归一样去实现。
## 27. http的状态码
#### 1xx 请求正在处理
#### 2xx 请求成功
1. 200 请求完成
2. 204是客户端向服务端发送消息而服务端不需要返回信息
#### 3xx 重定向
1. 301是永久重定向
2. 302是临时重定向
3. 303是资源还有另一个url用get来获取资源，
4. 304是缓存的一个状态码
#### 4xx 浏览器错误
1. 400是请求报文出现错误
2. 403是被服务器拒绝
3. 404是无法找到所需的资源
4. 
#### 5xx 服务器错误
1. 500是服务端在执行请求时发生错误
2. 503是服务端在维护或者超负荷

## 28. const类型能不能更改
const类型在创建的时候是必须赋值的，所以他被赋值的时候是一个常量，如果后续修改会报错。但是他所指向的指针是不变的，可是如果是引用数据类型，那么指向的数据存放地址不可改变，引用数据类型指向的堆是可以改变的。
## 29. sessionStorage和localStorage的区别
seeeionStorage与locStorage都是用来存储数据的，主要是数据的保存方式不同，local是保存在本地，除非主动去删除，否则会一直保存，而sessions是只能在当前页面与浏览器使用，关闭页面的时候会删除里面的内容。cookie则是保存的数据较少，而且是可以用来传递的数据，seeeionStorage与locStorage则存储量较大，可一般用在当前页面或者持久化存储。
## 30. websocket
是基于tcp协议的一种使前后端通讯的技术，因为一般都是客户端主动向服务器发送请求，然后获取资源，而websocket则是可以通过一次链接，使服务器与客户端进行全双工通讯。优点是没有同源政策，可以双向进行通讯而且只用第一次有请求头，负荷小，并且每次只需要一次连接，快速，缺点是有一些低版本浏览器无法兼容

## 31. 跨域
跨域是因为浏览器不允许不同的域名之间进行某些操作，如读取cookie，js操作dom这样的操作，这是因为同源政策的限制，需要进行某些操作进行修改后可以实现跨域。

1. jsonp:利用script标签的src属性不受同源策略的限制，并且资源加载完成后会被当作js脚本立即执行的特点，来达到跨域请求资源的目的。主要是创建一个script节点然后创建src和通过后端的callback实现跨域。（只能使用get）
2. window.name
3. cors分为简单请求和非简单请求。这是官方浏览器支持的方法，一般来说跨域都是要前后端协作才能完成的。像在cors里简单请求的话是请求头要是get，post，head，在请求的时候会带入一个origin，如果服务器返回Access-Control-Allow-Origin则是通过请求。
## 32. dom与虚拟dom是什么
dom是document obeject model ，是文档对象模型，主要是树形与节点组成，浏览器通过对dom的渲染和操作可以更改和展现网页，而虚拟dom是js对象模拟的一个dom，对虚拟dom的更改不会引起页面的重排重绘，所以在虚拟dom最后一次性的和dom进行比较然后通过render渲染，可以有效降低dom操作和页面的重排重绘，提高可维护性和性能。
## 33. 前端框架和原生的js优缺点分析
前端框架主要是为了模块化和工程化的开发，也为了让整个项目开发的时候更简单高效。而且像react和vue都是spa单页面的，前后端分工会更明确一点，但可能在seo上不如原生的js。而在学习框架的时候，如在官方文档学习，就会觉得入门相对原生更容易但是在后面也更容易遇到瓶颈，因为学习的东西需要更多更杂。最重要的一点可能是在使用框架的时候是使用声明式去操作dom而不是命令式的，就是使用js模拟的一个dom这样去现在操作，减少了重排重绘也减少了直接对dom的操作，效率更高，性能更好。
## 34. js为什么是单线程的
因为js在运行过程中是对dom的操作，而在操作过程中如果是多线程的，那俩个dom操作同时进行则无法判断对哪一个进行操作。
## 35. html的语义化理解
html的语义化是为了减少div的使用，因为之前可能对于页面的编写是通过div＋class选择器进行绘制，而语义化则是使用main，footer等标签进行编写，页面更工程化，模块化。而滥用div不仅会使代码更难看懂，而且对于seo没有帮助。语义化可以让文档更好读，并且在抓取关键词上更有优势。
## 36. 低代码平台怎么通过json渲染成组件
首先低代码平台这个框架是基于Avue和element这样的组件库，其中由于element组件库是有许多api，在json这样的树形结构中，通过props来绑定对应的组件，再提取树中相对应的api值进行渲染。
## 37. vue2与vue3的区别
1. 在vue2中使用选项式API，在vue3中使用组合式API
2. 俩个的响应式原理不同，像vue2使用object，vue3使用proxy。
3. vue3支持ts支持
4. 生命周期的不同
## 38. 防抖和节流
防抖就是在一段时间内再进行操作会使操作重置，重新开始计时。
节流是在一段时间内操作不会使操作重置，在这个操作结束后会进行下一次操作
防抖的代码：
```js
function debounce(func,wait){
       var that=this
       let timeout=null
       return function(){
       ClearTimeout(timeout)
       timeout=settimeout(()=>{
           func.apply(that)
       },wait)
       }
}
```
节流的代码:

```js
function debounce(func,wait){
       var that=this
       let timeout
       if(!timeout){
       return function(){
       timeout=settimeout(()=>{
           func.apply(that)
           timeout=null
       },wait)
       }}

}
```

## 39. vue的mixin
俩个组件有相同的功能但是他们的内容不一样时可以使用mixin，俩个组件可以共享一个配置。但是一般不用mixin，因为会造成方法的混淆。可以在全局或者局部混入mixin。
## 40. vite与webpack的打包过程或者配置
webpack的打包过程：
参数编写  开始编译  找到入口  编译模块  递归展开模块依赖图   将模块拆成chunk然后变成文件放入
而像vite的模块编写都是浏览器去做，等到需要哪一些模块的时候则是取出相对应的模块。
## 41. vuex
vue的状态管理，多用于一个数据需要在多个组件中使用的情况下，可以集中管理许多数据的状态，具有，state，getters，mutations，actions，modules，state就像data用来存储不同的状态，getters则是用来进行计算的，mtations相当于methods可以啦进行函数操作，actions则是进行异步的muattions，modules则是为了防止vuex数据过大太臃肿可以将不同的状态的不同store分割
## 42. 数组的includes
可以查看是否存在某个数，也可以使用indexof，filter实现

